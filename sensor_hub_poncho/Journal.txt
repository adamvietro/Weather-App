Chapter 1: Elixir and Nerves for IoT
    You will understand the way in which Nerves can help with IoT (Internet of Things). You will build your Pi and then flash the Nerves bare-bones and then make sure it can connect wirelessly to the main computer without any direct connections.

    Why Nerves for IoT?
        IoT is all about interconnected computational Devices geographically distributed. It is a way to keep track of the cars or devices on your network so you can keep live up to date data about any node on the network. Nerves comes in as it will allow you to use consumer-available hardware to build everything from scratch.

    Time-Series Sensor Hub
        You will use Nerves to framework to build the sensor hub and then use Phoenix to build a RESTful API.

        Although you could use PostgreSQL for this the nature of the data will be time-series. Thus we want to use a data-base that is built around that, so TimescaleDB will work well here. This will automatically parse your data into describe chunks that will be more able to be used for our project. 

        To Note: There is even a space partition for the data that can be helpful for making sure that you are noting where the data is coming from this would work well for any true weather app as where the data comes from can be crucial.

    Laying Our the Architecture
        We will have: 
            Data Stations
            {
                Nerves Weather Stations
            }
            Data Transfer
            {
                Public Internet
            }
            Public Interface
            {
                Phoenix REST API
                Time-series Database
                Grafana
                Users
            }
        
        Definition: Cardinality
            This is the amount of Data that a column should have. A UserID should have high cardinality as each user will have their own unique ID, but something like User_Type will have low cardinality as each user will only have 3 or more values: Admin, Basic, Paid, etc.

        Once we have the node up we will use Phoenix to push the data onto the DB and once that is done the Phoenix part will be over (unless you want to post the data). But for the simple case you can use Grafana to visualize the data.

        New Tech: Grafana is used to connect to different databases, it will be hosted via Docker and will help us interact and visualize the data we are receiving. 

    Organizing Your Nerves Project
        Nerves Projects have their own structure that make embedding an Elixir project really convenient. 

        Planning Features
            Here are the individual features we need to build:
                Each Sensor will need to have its own GenServer and will be responsible for collecting it's sensor's measurements
                Our Raspberry Pit will have a GenServer that will capture measurements from the connected sensors and publish them to Phoenix API
                Nerves Firmware will start all the GenServers and the HTTP Publisher GenServer. This is the glue that will hold everything together.
        
        Organizing the Project
            We will use what is called a Poncho Project for Nerves as it will help us keep the Elixir project structured as well as all the Firmware of the project. Thus allowing us to have decencies separate and still allowing us to share it we need. 
            
            Definition: Poncho Project
                Alternative to umbrella projects: Poncho projects are a way to organize Elixir applications that are related but don't require the strict structure and interdependencies of an umbrella project.
            
            Here is the poncho project structure:
                |-- Sensor_hub_poncho
                    |-- publisher
                    |-- sensor_hub
                    |-- veml6030

                    This the top level will be created with a simple mkdir and then the subdirectories can be made with mix new and should have their own config. 

                sensor_hub is your firmware project this should deal with:
                    configuration, life-cycle concerns, dependencies, and glue code
                    So you will need to add other projects into the dependencies of the sensor_hub
                
            Poncho Projects will also have 2 types of dependency projects:
                Hardware dependency projects; these don't need firmware as you will write to the hardware interfaces. veml6030 is like this as you will only wrap the light sensor.

                Hardware-independent dependency; this implies that you will have code that will go to many types of hardware and will need to run on all of them. *publisher* is an example of this, it provides our HTTP API client. 

            Firmware projects will connect to dependency projects using path dependencies.

    Assembling the Weather Station
        We will need an sensor array for this project as many times it will need to be build with solder and a breakout board, but we will use a solderless board called Qwiic Connect System.

        Definition: I2C
            Inter-Integrated Circuit is a communication protocol that allows us to connect multiple external devices to one or more hosts. 

        Gathering Hardware
            Check out all the bookmarks but I think I have everything I need with the links that Cut sent.

        Assembling the Sensor Hub
            
Chapter 2 Wirelessly Reading Sensor Data (15)
    Creating a Network-Enabled Sensor Hub Project
        We want to generate a new Nerves Project (I made sure that I have all the needed libs for Nerves with the site https://hexdocs.pm/nerves/installation.html)
        Burning the Firmware
        Connecting the device via SSH
        Setting the network settings.

        First we will start by creating the top level directory.
            $ mkdir sensor_hub_poncho
            $ cd sensor_hub_poncho
            $ mix nerves.new sensor_hub
        
        For the next parts we need to tell Nerves what "target" you're acting upon. Also be ready to burn the firmware to the SD card and be sure that it is the only card installed. 
            $ cd sensor_hub
            $ export MIX_TARGET=rpi0
            $ mix deps.get
            ...
            $ mix firmware

            # I got an error here that said that I have a version mismatch for Erlang so I went ahead and installed Erlang version 27
                # Step 1: Install Erlang versions
                asdf install erlang 27.0
                asdf install erlang 28.0

                # Step 2: Install matching Elixir versions
                asdf install elixir 1.19.0-rc.0-otp-27
                asdf install elixir 1.19.0-rc.0-otp-28

                # Step 3: Set global Elixir version to OTP 28 (temporary or overwritten later)
                asdf global elixir 1.19.0-rc.0-otp-28

                # Step 4: Set global Elixir version to OTP 27 (final)
                asdf global elixir 1.19.0-rc.0-otp-27

                # Step 5: Set global Erlang version to match Elixir OTP 27
                asdf global erlang 27.0

                # Step 6: Clean and rebuild your Nerves project (run inside project folder)
                rm -rf _build deps
                mix deps.get
                mix compile

                # Step 7: Verify installed versions
                erl -version
                elixir --version

                # Step 8: To switch to Erlang 28 + Elixir OTP 28 when needed (per shell session)
                asdf shell erlang 28.0
                asdf shell elixir 1.19.0-rc.0-otp-28

                # Alternatively, create a `.tool-versions` file in the project directory:
                # erlang 28.0
                # elixir 1.19.0-rc.0-otp-28

                # Optional:
                # - Create `.tool-versions` files per project for automatic version switching.
                # - Remove any system-wide Erlang/Elixir versions outside `asdf` to avoid conflicts.
                # - Ensure your shell config loads `asdf` properly.

                # This then gave me an error about needing an other version of elixir so again we change the version
                asdf install elixir 1.18.3-otp-27
                asdf global elixir 1.18.3-otp-27

                # Then rebuild
                mix deps.clean --all
                mix deps.get
                mix deps.compile
                mix firmware

                ...
                $ mix burn
            ==> nerves
            ==> sensor_hub
            Nerves environment
            MIX_TARGET: rpi0
            MIX_ENV: dev
            Use 14.84 GiB memory card found at /dev/rdisk2? [Yn] y
            100% [====================================] 33.32 MB in / 35.76 MB out
            Success!
            Elapsed time: 4.765 s

        We now have a firmware burned into the Raspberry Pi and you can now insert the card into the Pi. Let's turn it on and SSH into it

            ssh nerves.local
            ...
            iex(1)> hostname()
            "nerves-dc74"
            iex(2)> exit()
            Connection to nerves.local closed

                    # 
                        At the moment the ssh isn't working so I'm going to try to go right to WIFI.
                            You need to add :inets to the extra_applications.

                            Then you can set the wifi network with Vintage.Net.configure()
                                iex(1)> VintageNet.configure("wlan0", %{
                                ...(1)> type: VintageNetWiFi,
                                ...(1)> vintage_net_wifi: %{
                                ...(1)> networks: [%{
                                ...(1)> key_mgmt: :wpa_psk,
                                ...(1)> ssid: "<YOUR NETWORK NAME>",
                                ...(1)> psk: "<YOUR WIRELESS PASSWORD>"
                                ...(1)> }]
                                ...(1)> },
                                ...(1)> ipv4: %{method: :dhcp}
                                ...(1)> })

                        This won't work for me as I can't SSH atm so I will create a hardcoded version of the setting. To do so I need to create a file under:
                            rootfs_overlay/etc/vintage_net/config/network.config

                        Once that was done you need to add this line to the release within the mix.exs:
                            rootfs_overlay: "rootfs_overlay",

                        With these settings:
                            [
                                {
                                    "wlan0",
                                    %{
                                    type: VintageNetWiFi,
                                    vintage_net_wifi: %{
                                        networks: [
                                        %{
                                            key_mgmt: :wpa_psk,
                                            ssid: "YourWiFiSSID",
                                            psk: "YourWiFiPassword"
                                        }
                                        ]
                                    },
                                    ipv4: %{method: :dhcp}
                                    }
                                }
                            ]

                        Then I need to get the new deps and create the new firmware then burn it to the SD card.
                            MIX_TARGET=rpi0
                            mix firmware
                            mix burn

                        That didn't work so now I'm trying to be sure that I have everything installed. Check out this page to help you get everything installed.
                        https://hexdocs.pm/nerves/installation.html
                        It seems that the wx install isn't working for that page and I found that wx is not autoinstalled with the latest version of Unbuntu so I found this page:
                        https://askubuntu.com/questions/1522789/e-unable-to-locate-package-libwxgtk3-0-gtk3-dev

                        I have everything I think I need installed atm I will try to redo the firmware and burn.

        Okay so check out this site in-order to get the auto connect for the wifi (https://github.com/nerves-networking/vintage_net). With making sure that the right firmware (rpi3a) and setting the right version of the wifi setup.
            config :vintage_net,
            regulatory_domain: "US", # Change to match your area
            config: [
                {"eth0", %{
                type: VintageNetEthernet,
                ipv4: %{
                    method: :dhcp
                }
                }},
                {"wlan0",
                %{
                    type: VintageNetWiFi,
                    vintage_net_wifi: %{
                    networks: [
                        %{
                        key_mgmt: :wpa_psk,
                        ssid: "Your WiFi SSID",
                        psk: "passphrase or psk",
                        }
                    ]
                    },
                    ipv4: %{method: :dhcp},
                }
                }
            ]

    Capturing Sensor Data
        Okay so now that we are ready to move onto the capture part of the process we need to download the spec sheet for the environmental hat (https://www.waveshare.com/environment-sensor-hat.htm). Here are some of the information that we will need:
            Light Sensor
                I2C address: 0x29
            Temp/Humidity/Air Pressure
                I2c address: 0x76
            Motion Sensor: 
                I2C adress: 0x68
            UV Sensor:
                I2C address: 0x53
            VOC Sensor:
                I2C address: 0x59

        These might be different for your device I was able to look up the sensor data on line and it even has them on the board itself. Some of the sensors will have different sensitivities so be sure to check those out too.

        Now let's change a few deps and then upload the new firmware. 
            $ mix deps.get
            ...
            $ mix firmware
            ...
            $ mix upload
            ...
            $ ssh nerves.local
            ...

        So again my current settings I was unable to use the nerves.local so I had to create an firmware update script and then use that to upload it to the pi.
            mix firmware.gen.script # This is instead of the mix upload
            ./upload.sh 192.168.x.x $ Your IP address of the pi

        Now you can ssh into the device.
            ssh 192.168.x.x
                    This is the way to do it with the basic sensor that the book is using.
                    Here is where we will start to take some the sensor data.
                        ex(1)> alias Circuits.I2C
                        Circuits.I2C
                        iex(2)> sensor = 0x29 # This is the address of the light sensor
                        72
                        iex(3)> command = <<0>>
                        <<0>>
                        iex(4)> byte_size = 2
                        2
                        iex(5)> {:ok, i2c_ref} = I2C.open("i2c-1")
                        {:ok, #Reference<0.1635386997.268828675.62058>}
                        iex(6)> <<value::little-16>> = I2C.write_read!(i2c_ref, sensor, command, 2)
                        <<1, 0>>
                        iex(7)> value |> inspect(base: :binary)
                        "0b0"

                    With the value of 0b0 being returned we know that the sensor is turned off. Let's turn it on.
                        iex(8)> config = 0b0001100000000000
                        6144
                        iex(9)> Circuits.I2C.write(i2c_ref, sensor, <<0, config::little-16>>)
                        :ok
                        iex(10)> <<value::little-16>> = I2C.write_read!(i2c_ref, sensor, command, 2)
                        <<0, 24>>
                        iex(11)> value |> inspect(base: :binary)
                        "0b1100000000000"

        This didn't work for me so Ill try an other way
            alias Circuits.I2C
            import Bitwise

            sensor = 0x29               # Sensor I2C address
            command_bit = 0x80          # Command bit to indicate command register (depends on sensor)
            enable_register = 0x00      # Register address to enable power and ALS
            config_register = 0x01      # Configuration register
            data_register = 0x14        # Data register address (where readings start)

            # Bit flags to enable power and ALS (ambient light sensing)
            enable_power_on = 0x01
            enable_als_enable = 0x02

            # Combine flags with bitwise OR
            enable_value = enable_power_on ||| enable_als_enable

            # Open I2C bus
            {:ok, i2c_ref} = I2C.open("i2c-1")

            # Write to enable register with command bit set
            I2C.write(i2c_ref, sensor, <<command_bit ||| enable_register, enable_value>>)

            # Optionally configure other registers here...

            # Read 2 bytes from the data register
            <<raw_value::little-16>> = I2C.write_read!(i2c_ref, sensor, <<command_bit ||| data_register>>, 2)

            IO.inspect(raw_value, base: :binary)

        Now we can start to do something with the sensor.
            iex(12)> light_reading = 4
            4
            iex(13)> <<value::little-16>> =
            ...(13)> Circuits.I2C.write_read!(i2c_ref, sensor, <<light_reading>>, 2)
            iex(14)> value
            440

        We get a value back. Now, put your hand over the sensor so that there’s less light and see if the value is lower:
            iex(15)> <<value::little-16>> =
            ...(15)> Circuits.I2C.write_read!(i2c_ref, sensor, <<light_reading>>, 2)
            iex(16)> value
            40

        Now we can try and transfor the data into something useful.
            iex(17)> measure_light = fn i2c, address ->
            ...(17)> <<value::little-16>> = I2C.write_read!(i2c, address, <<4>>, 2)
            ...(17)> value * 0.2304
            ...(17)> end
            #Function<43.97283095/2 in :erl_eval.expr/5>

            iex(16)> measure_light.(i2c_ref, sensor)
            57.6
        
    What you have done...
        Great job so far. You have created your first poncho project, you update the firmware and flashed it to an SD card, you then updated the config file so that your pi will automatically connect to the wifi network, you then started the sensor and got some raw values back, lastly you created a function that will turn the raw data into something that is more managable. 

Chapter 3 Aggregating Sensor Data (29)
    We now need to wrap each GenServer so that they will power on and gather data when the device is powered on. Each sensor needs to be its own GenServer and will have a Supervisor to deal with the start and aggrigration of the data.

    Wrapping Sensors in GenServers
        We will start a new mix project withing the Poncho
            $ mix new veml6030
            $ cd veml6030

        Once that is done we need to update the deps to have the i2c interface and firmware

            {:circuits_i2c, "~> 0.3.8"}

        This project will continue to get more and more complex so keeping the aggrigration in it's own project will help to keep everything in the right spot.

        Build a Core from the Spec Sheet
            Acronim: CRC mean to Construct |> Reduce |> Convert. This is the way we will take the raw data and make it useable for out site.

            Start off by creating a file at the location lib/veml6030/config.ex (this will go inside the veml6030 project and you will create an other veml6030 folder)
                defmodule Veml6030.Config do
                    defstruct [
                        gain: :gain_1_4th,
                        int_time: :it_100ms,
                        shutdown: false,
                        interrupt: false
                    ]

                    def new, do: struct(__MODULE__)
                    def new(opts) when is_list(opts) do
                        struct(__MODULE__, opts)
                    end
                end

            We now have the constructor out of the way now we need to deal with the converter. This will be the format of the integers that we will use.
                def to_integer(config) do
                    reserved = 0
                    persistence_protect = 0
                    <<integer::16>> = <<
                        reserved::3,
                        gain(config.gain)::2,
                        reserved::1,
                        int_time(config.int_time)::4,
                        persistence_protect::2,
                        reserved::2,
                        interrupt(config.interrupt)::1,
                        shutdown(config.shutdown)::1
                    >>
                    integer
                end

            This is what we will use to deal with all the settings of the sensors, in order to pattern match different settings. These will take a setting we want and transform them into bits based off the spec sheet. 
                defp gain(:gain_1x), do: 0b0
                defp gain(:gain_2x), do: 0b01
                defp gain(:gain_1_8th), do: 0b10
                defp gain(:gain_1_4th), do: 0b11
                defp gain(:gain_default), do: 0b11
                defp int_time(:it_25_ms), do: 0b1100
                defp int_time(:it_50_ms), do: 0b1000
                defp int_time(:it_100_ms), do: 0b0000
                defp int_time(:it_200_ms), do: 0b0001
                defp int_time(:it_400_ms), do: 0b0010
                defp int_time(:it_800_ms), do: 0b0011
                defp int_time(:it_default), do: 0b0000
                defp shutdown(true), do: 1
                defp shutdown(_), do: 0
                defp interrupt(true), do: 1
                defp interrupt(_), do: 0

            We will now need to worry about the conversion factor for the values that we get from the sensor.
                @to_lumens_factor %{
                    {:it_800_ms, :gain_2x} => 0.0036,
                    {:it_800_ms, :gain_1x} => 0.0072,
                    {:it_800_ms, :gain_1_4th} => 0.0288,
                    {:it_800_ms, :gain_1_8th} => 0.0576,
                    {:it_400_ms, :gain_2x} => 0.0072,
                    {:it_400_ms, :gain_1x} => 0.0144,
                    {:it_400_ms, :gain_1_4th} => 0.0576,
                    {:it_400_ms, :gain_1_8th} => 0.1152,
                    {:it_200_ms, :gain_2x} => 0.0144,
                    {:it_200_ms, :gain_1x} => 0.0288,
                    {:it_200_ms, :gain_1_4th} => 0.1152,
                    {:it_200_ms, :gain_1_8th} => 0.2304,
                    {:it_100_ms, :gain_2x} => 0.0288,
                    {:it_100_ms, :gain_1x} => 0.0576,
                    {:it_100_ms, :gain_1_4th} => 0.2304,
                    {:it_100_ms, :gain_1_8th} => 0.4608,
                    {:it_50_ms, :gain_2x} => 0.0576,
                    {:it_50_ms, :gain_1x} => 0.1152,
                    {:it_50_ms, :gain_1_4th} => 0.4608,
                    {:it_50_ms, :gain_1_8th} => 0.9216,
                    {:it_25_ms, :gain_2x} => 0.1152,
                    {:it_25_ms, :gain_1x} => 0.2304,
                    {:it_25_ms, :gain_1_4th} => 0.9216,
                    {:it_25_ms, :gain_1_8th} => 1.8432
                }

                def to_lumens(config, measurement) do
                    @to_lumens_factor[{config.int_time, config.gain}] * measurement
                end
                            
            Let's take it on a test drive
                iex(1) ▶ VEML6030.Config.new()
                %VEML6030.Config{
                gain: :gain_1_4th,
                int_time: :it_100_ms,
                interrupt: false,
                shutdown: false
                }
                iex(2) ▶ VEML6030.Config.new() |>
                ...(2) ▶ VEML6030.Config.to_integer() |>
                ...(2) ▶ inspect(base: :hex)
                "0x1800"
                iex(3) ▶ [gain: :gain_1x] |>
                ...(3) ▶ VEML6030.Config.new() |>
                ...(3) ▶ VEML6030.Config.to_integer() |>
                ...(3) ▶ inspect(base: :hex)
                "0x0"

        Create Boundary Hardware Layer (33)
            We now have the frame work for dealing with the general configuration. We shield a user from the tedium of dealing with the different settings too.

            We will not create a new file at lib/veml6030/comm.ex
            defmodule Veml6030.Comm do
                aliaa Circuits.I2C
                alias VEML6030.Config

                @light_register <<4>>
                # These will set up the alias for the previously made files

                @doc """
                    This will help us discover posibble adresses.
                """
                def discover(possible_addresses \\ [0x10, 0x48]) do
                    I2C.discover_one!(possible_addresses)
                end

                @doc """ 
                    We open a bus with this and it will raise a failure if it doesn't work and we can "let it
                    heal"
                """
                def open(bus_name) do
                    {:ok, i2c} = I2C.open(bus_name)
                    i2c
                end

                @doc """
                    We will need to write a config or a command to the senser.
                """
                def write_config(configuration, i2c, sensor) do
                    command = Config.to_integer(configuration)

                    I2C.write(i2c, sensor, <<0, command::little-16>>)
                end

                @doc """
                    This is for dealing with the sensor data and uses the configuration to convert it.
                """
                def read(i2c, sensor, configuration) do
                    <<value::little-16>> =
                    I2C.write_read(i2c, sensor, @light_register, 2)

                    Config.to_lumens(configuration, value)
                end
            end

        Wrap the core and Hardware in a GenServer (35)
            We will want to wrap all the sensor comms witin a GenServer, as it will handle most all the communication we will put it at the top of the file structure (lib/veml6030/ex). The mix new will have created a sample veml6030.ex file and you can just replace it with the below. Check the comments and the @doc to see about each function and call.
                defmodule Veml6030 do
                    use GenServer

                    require Logger

                    alias Veml6030.{Comm, Config}

                    @moduledoc """
                    A GenServer for the VEML6030 light sensor. It reads the light level
                    and converts it to lumens based on the configuration provided.
                    The sensor can be configured with different gain and integration times.
                    """
                    def start_link(options \\ %{}) do
                        GenServer.start_link(__MODULE__, options, name: __MODULE__)
                    end

                    def get_measurement do
                        GenServer.call(__MODULE__, :get_measurement)
                    end

                    @doc """
                    Starts the VEML6030 GenServer with the given options. It will start the and then set an interval to
                    read and then log the light reading every second.
                    """
                    def init(%{address: address, i2c_bus_name: bus_name} = args) do
                        i2c = Comm.open(bus_name)

                        config =
                        args
                        |> Map.take([:gain, :int_time, :shutdown, :interrupt])
                        |> Config.new()

                        Comm.write_config(config, i2c, address)
                        :timer.send_interval(1_000, :measure)

                        state = %{
                        i2c: i2c,
                        address: address,
                        config: config,
                        last_reading: :no_reading
                        }

                        {:ok, state}
                    end

                    @doc """
                    Starts the VEML6030 GenServer with the default configuration. This is for when you don't
                    have the correct bus and address set.
                    """
                    def init(args) do
                        {bus_name, address} = Comm.discover()
                        transport = "bus: #{bus_name}, address: #{address}"

                        Logger.info("Starting VEML6030. Please specify an address and a bus")
                        Logger.info("Starting on " <> transport)

                        defaults =
                        args
                        |> Map.put(:adress, address)
                        |> Map.put(:i2c_bus_name, bus_name)

                        init(defaults)
                    end

                    @doc """
                    This are set to take the last reading froom the sensor, then update the reading with the new reading and
                    appening it to the state.
                    """
                    @impl true
                    def handle_info(:measure, %{i2c: i2c, address: address, config: config} = state) do
                        last_reading = Comm.read(i2c, address, config)
                        updated_with_reading = %{state | last_reading: last_reading}

                        {:noreply, updated_with_reading}
                    end

                    @doc """
                    This is for calling the GenServer to get the last reading from the sensor.
                    """
                    @impl true
                    def handle_call(:get_measurement, _from, state) do
                        {:reply, state.last_reading, state}
                    end
                end
        
            We now need to add in the new deps to the mix.ex in the sensor_hub project.
                defp deps do
                    [
                    ...
                    # Dependencies for all targets except :host
                    {:veml6030, path: "../veml6030", targets: @all_targets},
                    ...
                    ]
                end

            Then we will need to get the new deps and then recreate the firmware and then upload the new firmware then shh into the Raspberry Pi
                $ cd sensor_hub
                $ mix deps.get
                ...
                $ mix firmware
                ...
                report erratum • discuss
                $ mix upload
                ...
                # You may have to wait a little until the device reboots
                $ ssh nerves.local
                ...

            Then run these commands
                iex(1)> VEML6030.start_link()
                {:ok, #PID<0.1278.0>}
                iex(2)> VEML6030.get_measurement() # Hand covering the sensor
                6.4512
                iex(3)> VEML6030.get_measurement() # Hand not covering the sensor
                71.6544

    Quicknote: So when building the project names for the modules I was using the VScode auto fill for the name of the modules. In the book we used all uppercase characters for the Modules, so when try to use the built-in functions and then the other things we ran into issues that I should have seen just from the warnings. Keep the case of the characters in mind when building the modules.

    Also the address of the light sensor on my environmental hat is 0x29 not 0x48 so I had to change that in the comm.ex file in the possible address.

    I think that I might need to change some of the settings in order to get my light sensor to turn on. So Ill keep coming back to this but I will need to set some new functions. 

    First I will rename the module to the right Sensor TSL25911FN
        config.ex
            import Bitwise

            def to_control_byte(%__MODULE__{gain: gain, int_time: int_time}) do
                (gain(gain) <<< 4) ||| int_time(int_time)
            end

            def to_enable_byte(%__MODULE__{shutdown: shutdown, interrupt: interrupt}) do
                shutdown_bit = if shutdown, do: 0, else: 1
                interrupt_bit = if interrupt, do: 1, else: 0

                (interrupt_bit <<< 4) ||| (1 <<< 1) ||| shutdown_bit
            end

            defp gain(:low), do: 0b00
            defp gain(:med), do: 0b01
            defp gain(:high), do: 0b10
            defp gain(:max), do: 0b11
            defp gain(:gain_default), do: 0b11

            defp int_time(:it_100_ms), do: 0b000
            defp int_time(:it_200_ms), do: 0b001
            defp int_time(:it_300_ms), do: 0b010
            defp int_time(:it_400_ms), do: 0b011
            defp int_time(:it_500_ms), do: 0b100
            defp int_time(:it_600_ms), do: 0b101
            defp int_time(:it_default), do: 0b000

            @to_lumens_factor %{
                {:it_100_ms, :low} => 0.0288,
                {:it_100_ms, :med} => 0.0576,
                {:it_100_ms, :high} => 0.2304,
                {:it_100_ms, :max} => 0.4608,
                {:it_200_ms, :low} => 0.0144,
                {:it_200_ms, :med} => 0.0288,
                {:it_200_ms, :high} => 0.1152,
                {:it_200_ms, :max} => 0.2304,
                {:it_300_ms, :low} => 0.0108,
                {:it_300_ms, :med} => 0.0216,
                {:it_300_ms, :high} => 0.0864,
                {:it_300_ms, :max} => 0.1728,
                {:it_400_ms, :low} => 0.0072,
                {:it_400_ms, :med} => 0.0144,
                {:it_400_ms, :high} => 0.0576,
                {:it_400_ms, :max} => 0.1152,
                {:it_500_ms, :low} => 0.0063,
                {:it_500_ms, :med} => 0.0126,
                {:it_500_ms, :high} => 0.0504,
                {:it_500_ms, :max} => 0.1008,
                {:it_600_ms, :low} => 0.0054,
                {:it_600_ms, :med} => 0.0108,
                {:it_600_ms, :high} => 0.0432,
                {:it_600_ms, :max} => 0.0864
            }     

        comm.ex
            import Bitwise

            @command_bit 0x80
            @enable_register 0x00
            @control_register 0x01
            @als_data_register 0x14

            def write_config(config, i2c, sensor) do
                enable_byte = Config.to_enable_byte(config)
                control_byte = Config.to_control_byte(config)

                # Write ENABLE register (1 byte) with command bit set
                I2C.write(i2c, sensor, <<@command_bit ||| @enable_register, enable_byte>>)

                # Write CONTROL register (1 byte) with command bit set
                I2C.write(i2c, sensor, <<@command_bit ||| @control_register, control_byte>>)
            end

            def read(i2c, sensor, config) do
                # Read 2 bytes from ALS data registers (low and high)
                # The write_read! call: write the register address, then read 2 bytes
                <<value::little-16>> = I2C.write_read!(i2c, sensor, <<@als_data_register>>, 2)

                Config.to_lumens(config, value)
            end

        TSL25911FN.ex
            Very little changed here as all the changes were just changing the VEML6030 to TSL25911FN. Once that was done all you have to do is use the exisiting code. However the book didn't have the correct line for the resend of the update so I had to add that in.

            @impl true
                def handle_info(:measure, %{i2c: i2c, address: address, config: config, integration_ms: integration_ms} = state) do
                last_reading = Comm.read(i2c, address, config)
                updated_state = %{state | last_reading: last_reading}

                # schedule next measurement after integration_ms milliseconds
                Process.send_after(self(), :measure, integration_ms)

                {:noreply, updated_state}
            end


        TSL25911FN/mix.exs
            def project do
                [
                app: :TSL25911FN,
                version: "0.1.0",
                elixir: "~> 1.18",
                start_permanent: Mix.env() == :prod,
                deps: deps()
                ]
            end


        sensor_hub/mix.exs
            {:TSL25911FN, path: "../TSL25911FN", targets: @all_targets},

    With all this done you can run.
        ./upload.sh 192.168.x.x
        ssh 192.168.x.x

        alias TSL25911FN, as: TSL 
        TSL.start_link()
        TSL.get_measurement()
        TSL.measure()
        TSL.get_measurement()

    So this below works Ive been trying to make it work for the code that I have.
        import Bitwise
        {:ok, i2c} = Circuits.I2C.open("i2c-1")
        sensor = 0x29

        # Enable sensor: power on + ALS enable
        Circuits.I2C.write(i2c, sensor, <<0x80 ||| 0x00, 0x03>>)

        # Set integration time and gain (example values)
        Circuits.I2C.write(i2c, sensor, <<0x80 ||| 0x01, 0x10>>) 

        :timer.sleep(500)

        # Read raw ADC channels
        <<ch0::little-16, ch1::little-16>> = Circuits.I2C.write_read!(i2c, sensor, <<0x80 ||| 0x14>>, 4)
        IO.puts("CH0: #{ch0}, CH1: #{ch1}")

Build all the Sensor Config and Comm. (38)
    Now we need to include the right dependencies for the other sensors that we have on the hat. In the book they talk about using some predefined libs :bmp280 and :sgp30 which will take some the needed functions in order to use the sensors. I might need to define my own but Ill see about using some libs if I can find them.

    In order to make this work with the current settings I will write my own conn.ex, config.ex and sensor_name.ex files. Keep in mind you will need to add in the dependencies to the sensor hub after you make them in order to add them to the Supervisor tree.

    TLR390-UV-1
    conn.ex
        This is where I took a lot of the existing code and added in some of the new addresses and made sure that I set all the correct values in the config.

        @command_bit 0x80
        @enable_register 0x00
        @gain_register 0x05
        @control_register 0x04
        @als_data_register [0x0D, 0x0E, 0x0F]
        @uvs_data_register [0x10, 0x11, 0x12]

        def write_config(config, i2c, sensor) do
            enable_byte = Config.to_enable_byte(config)
            control_byte = Config.to_control_byte(config)
            gain_byte = Config.to_gain_byte(config)

            # Write ENABLE register (1 byte) with command bit set
            I2C.write(i2c, sensor, <<@command_bit ||| @enable_register, enable_byte>>)

            # Write CONTROL register (1 byte) with command bit set
            I2C.write(i2c, sensor, <<@command_bit ||| @control_register, control_byte>>)

            # Write the GAIN register
            I2C.write(i2c, sensor, <<@command_bit ||| @gain_register, gain_byte>>)
        end

        The sensor for UV has two types of sensors so I needed to be sure that I set both of them and could read from either.

        def read(i2c, sensor, %Config{uvs_als: :uvs} = config) do
            <<low, mid, high>> =
            I2C.write_read!(i2c, sensor, <<@command_bit ||| hd(@uvs_data_register)>>, 3)

            raw = low ||| mid <<< 8 ||| high <<< 16
            Config.uvs_to_uvi(config, raw)
        end

        def read(i2c, sensor, %Config{uvs_als: :als} = config) do
            <<low, mid, high>> =
            I2C.write_read!(i2c, sensor, <<@command_bit ||| hd(@als_data_register)>>, 3)

            # Convert using ALS formula when you fix it
            raw = low ||| mid <<< 8 ||| high <<< 16
            Config.als_to_lux(config, raw, 0)
        end

    config.ex
        This is where I had to set some new values for the struct and because there are some hardcoded formula that I would use for the conversion I set those values here too.

        @uv_sensitivity_base 2300.0

        defstruct resolution: :res_default,
                    measure_rate: :measure_rate_100_ms,
                    uvs_als: :uvs,
                    gain: :low,
                    reset: false

        def new, do: struct(__MODULE__)

        def new(opts) do
            struct(__MODULE__, opts)
        end

        defp resolution(:res_20bit), do: 0b000
        defp resolution(:res_19bit), do: 0b001
        defp resolution(:res_18bit), do: 0b010
        defp resolution(:res_17bit), do: 0b011
        defp resolution(:res_16bit), do: 0b100
        defp resolution(:res_15bit), do: 0b101
        defp resolution(:res_default), do: 0b010

        defp measure_rate(:measure_rate_25_ms), do: 0b000
        defp measure_rate(:measure_rate_50_ms), do: 0b001
        defp measure_rate(:measure_rate_100_ms), do: 0b010
        defp measure_rate(:measure_rate_200_ms), do: 0b011
        defp measure_rate(:measure_rate_500_ms), do: 0b100
        defp measure_rate(:measure_rate_1000_ms), do: 0b101
        defp measure_rate(:measure_rate_2000_ms), do: 0b110
        defp measure_rate(:measure_rate_default), do: 0b010

        defp gain(:min), do: 0b000
        defp gain(:low), do: 0b001
        defp gain(:med), do: 0b010
        defp gain(:high), do: 0b011
        defp gain(:max), do: 0b100
        defp gain(:gain_default), do: 0b001
        defp uvs_als(:uvs), do: 1
        defp uvs_als(:als), do: 0
        defp reset(true), do: 1
        defp reset(_), do: 0

        def to_control_byte(%__MODULE__{resolution: resolution, measure_rate: measure_rate}) do
            resolution(resolution) <<< 4 ||| measure_rate(measure_rate)
        end

        def to_gain_byte(%__MODULE__{gain: gain}) do
            gain(gain)
        end

        def to_enable_byte(%__MODULE__{uvs_als: uvs_als, reset: reset}) do
            reset_bit_rate = reset(reset) <<< 4
            uvs_als_bit_rate = uvs_als(uvs_als) <<< 3
            enable_bit_rate = 1 <<< 1
            reserve_bit_rate = 1 <<< 0

            reset_bit_rate ||| uvs_als_bit_rate ||| enable_bit_rate |||
            reserve_bit_rate
        end

        defp integration_time_ms(:measure_rate_25_ms), do: 25
        defp integration_time_ms(:measure_rate_50_ms), do: 50
        defp integration_time_ms(:measure_rate_100_ms), do: 100
        defp integration_time_ms(:measure_rate_200_ms), do: 200
        defp integration_time_ms(:measure_rate_500_ms), do: 500
        defp integration_time_ms(:measure_rate_1000_ms), do: 1000
        defp integration_time_ms(:measure_rate_2000_ms), do: 2000
        defp integration_time_ms(:measure_rate_default), do: 100

        def gain_multiplier(:min), do: 1
        def gain_multiplier(:low), do: 3
        def gain_multiplier(:med), do: 6
        def gain_multiplier(:high), do: 9
        def gain_multiplier(:max), do: 18

        def als_to_lux(%{gain: gain, measure_rate: measure_rate}, raw_counts, wfac \\ 1.0) do
            int_ms = integration_time_ms(measure_rate)
            raw_counts * 0.6 / (gain_multiplier(gain) * (int_ms / 100)) * wfac
        end

        def uvs_to_uvi(%{gain: gain, measure_rate: measure_rate}, raw_counts, wfac \\ 1.0) do
            int_ms = integration_time_ms(measure_rate)
            sensitivity = @uv_sensitivity_base * (gain_multiplier(gain) / 18) * (int_ms / 400)
            raw_counts / sensitivity * wfac
        end

    LTR390_UV.ex
        Again very similar to the other sensor but we have to get 2 types of measurements so I had to implement those.

        @impl true
        def init(%{address: address, i2c_bus_name: bus_name} = args) do
            i2c = Comm.open(bus_name)

            config =
            args
            |> Map.take([:gain, :resolution, :uvs_als, :measure_rate, :reset])
            |> Config.new()

            Comm.write_config(config, i2c, address)

            # Calculate measure rate in milliseconds (example mapping)
            measure_rate =
            case config.measure_rate do
                :it_25_ms -> 25
                :it_50_ms -> 50
                :it_100_ms -> 100
                :it_200_ms -> 200
                :it_500_ms -> 500
                :it_1000_ms -> 1000
                :it_2000_ms -> 2000
                _ -> 100
            end

            # Schedule first measure after measure_rate
            Process.send_after(self(), :measure, measure_rate)

            state = %{
            i2c: i2c,
            address: address,
            config: config,
            resolution: config.resolution,
            measure_rate: measure_rate,
            reset: config.reset,
            gain: config.gain,
            uvs_als: config.uvs_als,
            last_uvs: :no_reading,
            last_als: :no_reading
            }

            {:ok, state}
        end

        def init(args) do
            {bus_name, address} = Comm.discover()
            transport = "bus: #{bus_name}, address: #{address}"
            Logger.info("Starting LTR390_UV. Please specify an address and a bus.")
            Logger.info("Starting on " <> transport)

            defaults =
            args
            |> Map.put(:address, address)
            |> Map.put(:i2c_bus_name, bus_name)

            init(defaults)
        end

        @doc """
        This are set to take the last reading from the sensor, then update the reading with the new reading and
        appending it to the state. Once that is done it will switch to the other type of sensor and schedule an other
        reading.
        """
        @impl true
        def handle_info(
                :measure,
                %{
                i2c: i2c,
                address: address,
                config: config,
                measure_rate: measure_rate,
                uvs_als: current_mode
                } = state
            ) do
            last_reading = Comm.read(i2c, address, config)

            # Toggle mode and update config accordingly
            {new_state, new_config} =
            case current_mode do
                :uvs ->
                {%{state | last_uvs: last_reading, uvs_als: :als}, %{config | uvs_als: :als}}

                :als ->
                {%{state | last_als: last_reading, uvs_als: :uvs}, %{config | uvs_als: :uvs}}
            end

            # Write new config to switch sensor mode
            Comm.write_config(new_config, i2c, address)

            # Schedule next measurement after full measure_rate
            Process.send_after(self(), :measure, measure_rate)

            {:noreply, %{new_state | config: new_config}}
        end

        @doc """
        This is called when the GenServer is asked to get the last measurements for both uvs and als.
        """
        @impl true
        def handle_call(:get_measurement, _from, state) do
            last_uvs = state.last_uvs
            last_als = state.last_als
            {:reply, {last_uvs, last_als}, state}
        end

        @impl true
        def terminate(_reason, %{i2c: i2c}) do
            Circuits.I2C.close(i2c)
            :ok
        end

    To test run this:
        ./upload.sh 192.168.x.x
        ssh 192.168.x.x

        alias LTR390_UV, as: LTR 
        LTR.start_link()
        LTR.get_measurement()
        LTR.measure()

    BME280 (Humidity, Temperature, Air Pressure)
        Don't forget to add the {:circuits_i2c, "~> 1.1"} to the BME280 project and then add the :Bme280 to the sensor_but mix.exs

        config.ex
            defstruct mode: :normal,
                        osrs_t: :osrs_2x,
                        osrs_p: :osrs_16x,
                        osrs_h: :osrs_1x,
                        standby_time: :standby_0_5_ms,
                        filter: :filter_16,
                        spi3w_en: false

            def new, do: struct(__MODULE__)

            def new(opts) do
                struct(__MODULE__, opts)
            end

            @doc """
            This will be responsible for the: Humidity oversampling.
            """
            def to_ctrl_hum_byte(%__MODULE__{osrs_h: osrs_h}) do
                osrs_h_bit = osrs_h_to_bit(osrs_h)
                0b00000000 ||| osrs_h_bit
            end

            @doc """
            This will be responsible for the: Pressure oversampling, Temperature oversampling and
            the Mode that the sensor is currently operating in.
            """
            def to_ctrl_meas_byte(%__MODULE__{osrs_t: osrs_t, osrs_p: osrs_p, mode: mode}) do
                osrs_t_bit = osrs_t_to_bit(osrs_t)
                osrs_p_bit = osrs_p_to_bit(osrs_p)
                mode_bit = mode_to_bit(mode)
                0b00000000 ||| osrs_t_bit <<< 5 ||| osrs_p_bit <<< 2 ||| mode_bit
            end

            @doc """
            This will be responsable for the: filtering, standby time and SPI 3-wire mode.
            """
            def to_config_byte(%__MODULE__{standby_time: standby_time, filter: filter, spi3w_en: spi3w_en}) do
                standby_time_bit = standby_time_to_bit(standby_time)
                filter_bit = filter_to_bit(filter)
                spi3w_en_bit = spi3w_en_bit(spi3w_en)

                0b00000000 ||| standby_time_bit <<< 5 ||| filter_bit <<< 2 ||| spi3w_en_bit
            end

            @spec integration_ms(%__MODULE__{}) :: non_neg_integer()
            def integration_ms(%__MODULE__{
                    mode: mode,
                    osrs_t: osrs_t,
                    osrs_p: osrs_p,
                    osrs_h: osrs_h,
                    standby_time: standby_time
                }) do
                # Convert oversampling atoms to approximate times in ms
                t = osrs_to_ms(osrs_t)
                p = osrs_to_ms(osrs_p)
                h = osrs_to_ms(osrs_h)

                # Base measurement overhead (ms)
                base = 1

                # Standby time (ms)
                standby_ms =
                case mode do
                    :normal -> standby_time_to_ms(standby_time)
                    _ -> 0
                end

                # Total integration time
                total = t + p + h + base + standby_ms

                # Always round up to the nearest integer
                max(1, round(total))
            end

        comm.ex
            @ctrl_hum 0xF2
            @ctrl_meas 0xF4
            @config_register 0xF5
            @data_register 0xF7

            def write_config(config, i2c, sensor) do
                ctrl_hum_byte = Config.to_ctrl_hum_byte(config)
                ctrl_meas_byte = Config.to_ctrl_meas_byte(config)
                config_byte = Config.to_config_byte(config)

                # Write CTRL_HUM register (1 byte)
                I2C.write(i2c, sensor, <<@ctrl_hum, ctrl_hum_byte>>)

                :timer.sleep(100)  # Small delay to ensure the sensor is ready

                # Write CTRL_MEAS register (1 byte)
                I2C.write(i2c, sensor, <<@ctrl_meas, ctrl_meas_byte>>)

                # Write CONFIG register (1 byte)
                I2C.write(i2c, sensor, <<@config_register, config_byte>>)
            end

            def read(i2c, sensor) do
                <<press_msb, press_lsb, press_xlsb, temp_msb, temp_lsb, temp_xlsb, hum_msb, hum_lsb>> =
                I2C.write_read!(i2c, sensor, <<@data_register>>, 8)

                combined_pressure = (press_msb <<< 12) ||| (press_lsb <<< 4) ||| (press_xlsb >>> 4)
                combined_temperature = (temp_msb <<< 12) ||| (temp_lsb <<< 4) ||| (temp_xlsb >>> 4)
                combined_humidity = (hum_msb <<< 8) ||| hum_lsb

                {combined_pressure, combined_temperature, combined_humidity}
            end

        bme280.ex

        calibration.ex
            alias Bme280.Calibration

            @spec convert({integer, integer, integer}, Calibration.t()) ::
                    %{temperature_c: float, pressure_pa: float, humidity_rh: float}
            def convert({adc_P, adc_T, adc_H}, calib) do
                {temp_c, t_fine} = compensate_temp(adc_T, calib)
                press_pa = compensate_press(adc_P, t_fine, calib)
                hum_pct = compensate_hum(adc_H, t_fine, calib)

                %{
                temperature_c: temp_c,
                pressure_pa: press_pa,
                humidity_rh: hum_pct
                }
            end

            def compensate_temp(adc_T, calib) do
                var1 =
                (adc_T / 16384.0 - calib.dig_T1 / 1024.0) * calib.dig_T2

                var2 =
                (adc_T / 131_072.0 - calib.dig_T1 / 8192.0) *
                    (adc_T / 131_072.0 - calib.dig_T1 / 8192.0) *
                    calib.dig_T3

                t_fine = var1 + var2
                temperature = t_fine / 5120.0
                {temperature, t_fine}
            end

            def compensate_press(adc_P, t_fine, calib) do
                var1 = t_fine / 2.0 - 64000.0
                var2 = var1 * var1 * calib.dig_P6 / 32768.0
                var2 = var2 + var1 * calib.dig_P5 * 2.0
                var2 = var2 / 4.0 + calib.dig_P4 * 65536.0
                var3 = calib.dig_P3 * var1 * var1 / 524_288.0
                var1 = (var3 + calib.dig_P2 * var1) / 524_288.0
                var1 = (1.0 + var1 / 32768.0) * calib.dig_P1

                if var1 == 0 do
                0
                else
                p = 1_048_576.0 - adc_P
                p = (p - var2 / 4096.0) * 6250.0 / var1
                var1 = calib.dig_P9 * p * p / 2_147_483_648.0
                var2 = p * calib.dig_P8 / 32768.0
                p + (var1 + var2 + calib.dig_P7) / 16.0
                end
            end

            def compensate_hum(adc_H, t_fine, calib) do
                h = t_fine - 76800.0

                h =
                (adc_H - (calib.dig_H4 * 64.0 + calib.dig_H5 / 16384.0 * h)) *
                    (calib.dig_H2 / 65536.0) *
                    (1.0 +
                    calib.dig_H6 / 67_108_864.0 * h *
                        (1.0 + calib.dig_H3 / 67_108_864.0 * h))

                cond do
                h > 100.0 -> 100.0
                h < 0.0 -> 0.0
                true -> h
                end
            end
        converter.ex
            defstruct [
                :dig_T1,
                :dig_T2,
                :dig_T3,
                :dig_P1,
                :dig_P2,
                :dig_P3,
                :dig_P4,
                :dig_P5,
                :dig_P6,
                :dig_P7,
                :dig_P8,
                :dig_P9,
                :dig_H1,
                :dig_H2,
                :dig_H3,
                :dig_H4,
                :dig_H5,
                :dig_H6
            ]

            @temp_press_start 0x88
            # 0x88..0xA1
            @temp_press_len 26
            @hum_start 0xE1
            # 0xE1..0xE7
            @hum_len 7

            def read_all(i2c, sensor) do
                # Read temperature & pressure calibration (0x88..0xA0 = 25 bytes)
                t_p_data =
                I2C.write_read!(i2c, sensor, <<@temp_press_start>>, @temp_press_len)
                |> ensure_binary()

                <<
                dig_T1_lsb,
                dig_T1_msb,
                dig_T2_lsb,
                dig_T2_msb,
                dig_T3_lsb,
                dig_T3_msb,
                dig_P1_lsb,
                dig_P1_msb,
                dig_P2_lsb,
                dig_P2_msb,
                dig_P3_lsb,
                dig_P3_msb,
                dig_P4_lsb,
                dig_P4_msb,
                dig_P5_lsb,
                dig_P5_msb,
                dig_P6_lsb,
                dig_P6_msb,
                dig_P7_lsb,
                dig_P7_msb,
                dig_P8_lsb,
                dig_P8_msb,
                dig_P9_lsb,
                dig_P9_msb,
                _reserved,
                dig_H1
                >> = t_p_data

                # Read humidity calibration (0xE1..0xE7 = 7 bytes)
                h_data =
                I2C.write_read!(i2c, sensor, <<@hum_start>>, @hum_len)
                |> ensure_binary()

                <<dig_H2_lsb, dig_H2_msb, dig_H3, h4_lsb, h4_msb_bits, h5_msb_bits, dig_H6>> = h_data

                %__MODULE__{
                dig_T1: dig_T1_msb <<< 8 ||| dig_T1_lsb,
                dig_T2: signed(dig_T2_msb <<< 8 ||| dig_T2_lsb),
                dig_T3: signed(dig_T3_msb <<< 8 ||| dig_T3_lsb),
                dig_P1: dig_P1_msb <<< 8 ||| dig_P1_lsb,
                dig_P2: signed(dig_P2_msb <<< 8 ||| dig_P2_lsb),
                dig_P3: signed(dig_P3_msb <<< 8 ||| dig_P3_lsb),
                dig_P4: signed(dig_P4_msb <<< 8 ||| dig_P4_lsb),
                dig_P5: signed(dig_P5_msb <<< 8 ||| dig_P5_lsb),
                dig_P6: signed(dig_P6_msb <<< 8 ||| dig_P6_lsb),
                dig_P7: signed(dig_P7_msb <<< 8 ||| dig_P7_lsb),
                dig_P8: signed(dig_P8_msb <<< 8 ||| dig_P8_lsb),
                dig_P9: signed(dig_P9_msb <<< 8 ||| dig_P9_lsb),
                dig_H1: dig_H1,
                dig_H2: signed(dig_H2_msb <<< 8 ||| dig_H2_lsb),
                dig_H3: dig_H3,
                dig_H4: signed(h4_lsb <<< 4 ||| (h4_msb_bits &&& 0x0F)),
                dig_H5: signed((h5_msb_bits &&& 0xF0) >>> 4 ||| h5_msb_bits <<< 4),
                dig_H6: signed(dig_H6)
                }
            end

            defp signed(value) when value > 0x7FFF, do: value - 0x10000
            defp signed(value), do: value

            # Convert list to binary if needed
            defp ensure_binary(data) when is_list(data), do: :erlang.list_to_binary(data)
            defp ensure_binary(data) when is_binary(data), do: data
            
        export MIX_TARGET=rpi3a
        ./upload.sh 192.168.x.x
        ssh 192.168.x.x


        If you want to just test the comm.ex and config.ex
        alias Bme280.Comm
        alias Bme280.Config

        bus_name = "i2c-1"          # or whatever your I²C bus is
        {_bus, sensor} = Comm.discover()     # returns 0x76 (the sensor address)

        i2c = Comm.open(bus_name)    # open the bus
        config = Config.new()        # default config

        Comm.write_config(config, i2c, sensor)  # write config
        Comm.read(i2c, sensor)                  # read raw values

        if you want to test the GenServer on Bme280.ex
        Bme280.start_link()
        Bme280.get_measurement()

    SGP40
        config.ex
            @measure_cmd <<0x26, 0x0F>>
            @default_humidity <<0x80, 0x00, 0xA2>>
            @default_temperature <<0x66, 0x66, 0x93>>

            defstruct humidity: nil,
                        temperature: nil

            def new, do: struct(__MODULE__)

            def new(opts) do
                struct(__MODULE__, opts)
            end

            @doc """
            This will be responsible for the configuration byte.
            """
            def measure_frame(%__MODULE__{humidity: nil, temperature: nil}) do
                @measure_cmd <> @default_humidity <> @default_temperature
            end

            def measure_frame(%__MODULE__{humidity: hum, temperature: temp}) do
                hum_bytes = CrcHelper.encode_with_crc(hum)
                temp_bytes = CrcHelper.encode_with_crc(temp)
                @measure_cmd <> hum_bytes <> temp_bytes
            end

            def soft_reset do
                <<0x00, 0x06>>
            end

            def self_test do
                <<0x28, 0x0E>>
            end
        comm.ex
            def initialize_sensor(i2c, sensor) do
                with :ok <- I2C.write(i2c, sensor, Config.soft_reset()),
                    :timer.sleep(10),
                    :ok <- I2C.write(i2c, sensor, Config.self_test()),
                    :timer.sleep(250),
                    {:ok, <<msb, lsb, crc>>} <- I2C.read(i2c, sensor, 3),
                    true <- CrcHelper.crc8(<<msb, lsb>>) == crc do
                {:ok, :test_passed}
                else
                {:error, reason} ->
                    {:error, {:i2c_write_read_failed, reason}}

                false ->
                    {:error, :crc_failed}
                end
            end

            def measure(i2c, sensor, config) do
                frame = Config.measure_frame(config)
                I2C.write(i2c, sensor, frame)
                # measurement duration
                :timer.sleep(30)
                # read 2-byte VOC + CRC for each
                I2C.read(i2c, sensor, 6)
            end

        Sgp40.ex
            @impl true
            def init(%{address: address, i2c_bus_name: bus_name} = args) do
                i2c = Comm.open(bus_name)

                config =
                args
                |> Map.take([:temperature, :humidity])
                |> Config.new()

                Comm.initialize_sensor(i2c, address)

                # Standard time is ~30ms want to give it some more time.
                Process.send_after(self(), :measure, 100)

                state = %{
                i2c: i2c,
                address: address,
                config: config,
                last_reading: :no_reading,
                last_raw_reading: :no_reading
                }

                {:ok, state}
            end

            def init(args) do
                # Hardcoded bus and address
                bus_name = "i2c-1"
                address = 0x59
                transport = "bus: #{bus_name}, address: #{address}"
                Logger.info("Starting SGP40. Please specify an address and a bus.")
                Logger.info("Starting on " <> transport)

                defaults =
                args
                |> Map.put(:address, address)
                |> Map.put(:i2c_bus_name, bus_name)

                init(defaults)
            end

            @impl true
            def handle_info(:measure, %{i2c: i2c, address: address} = state) do
                case Comm.measure(i2c, address, state.config) do
                {:ok, raw} ->
                    Logger.info("SGP40 measurement taken: #{inspect(raw)}")
                    last_reading = CrcHelper.decode_voc(raw)
                    Process.send_after(self(), :measure, 50)
                    {:noreply, %{state | last_reading: last_reading, last_raw_reading: raw}}

                {:error, reason} ->
                    Logger.error("SGP40 measurement failed: #{inspect(reason)}")
                    Process.send_after(self(), :measure, 50)
                    {:noreply, state}
                end
            end

            @impl true
            def terminate(reason, state) do
                Logger.info("SGP40 GenServer terminating. Reason: #{inspect(reason)}")

                # Clean up I2C bus if it's open
                case state do
                %{i2c: i2c} when not is_nil(i2c) ->
                    Comm.close(i2c)
                    Logger.info("Closed I2C connection.")

                _ ->
                    Logger.warning("No I2C connection found to close.")
                end

                :ok
            end

            @impl true
            def handle_call(:get_measurement, _from, %{last_reading: last_reading} = state) do
                {:reply, last_reading, state}
            end
        
        crc_helper.ex
            @polynomial 0x31
            @init 0xFF

            @doc """
            Calculate the CRC-8 of a binary or list of bytes
            """
            def crc8(data) when is_binary(data), do: crc8(:binary.bin_to_list(data))

            def crc8(data) when is_list(data) do
                Enum.reduce(data, @init, fn byte, crc ->
                crc_byte(Bitwise.^^^(crc, byte))
                end)
            end

            # Process one byte through CRC
            defp crc_byte(byte) do
                Enum.reduce(0..7, byte, fn _, crc ->
                if (crc &&& 0x80) != 0 do
                    Bitwise.^^^(crc <<< 1, @polynomial) &&& 0xFF
                else
                    crc <<< 1 &&& 0xFF
                end
                end)
            end

            @doc """
            Encode a 2-byte word + CRC as required by the sensor
            Expects {msb, lsb} tuple
            """
            def encode_with_crc({msb, lsb}) do
                data = <<msb, lsb>>
                <<msb, lsb, crc8(data)>>
            end

            @doc """
            Convert raw SGP40 measurement (6 bytes) to VOC value in ppb.
            Expects <<msb, lsb, crc, _, _, _>> from get_measurement/0
            """
            def decode_voc(<<msb, lsb, crc, _, _, _>>) do
                if crc != crc8(<<msb, lsb>>) do
                {:error, :crc_mismatch}
                else
                raw = msb <<< 8 ||| lsb
                # Datasheet conversion: VOC index (0..500) ≈ raw / 65535 * 500
                voc_ppb = raw * 500 / 65_535
                {:ok, voc_ppb}
                end
            end

    If you want to just test the comm.ex and config.ex
        alias Sgp40.Comm
        alias Sgp40.Config

        bus_name = "i2c-1"          # or whatever your I²C bus is
        {_bus, sensor} = Comm.discover()     # returns 0x59 (the sensor address)

        i2c = Comm.open(bus_name)    # open the bus
        config = Config.new()        # default config

        Comm.write_config(config, i2c, sensor)  # write config
        Comm.read(i2c, sensor)                  # read raw values

    if you want to test the GenServer on Sgp40.ex
        Sgp40.start_link()
        Sgp40.get_measurement()

    Build the Firmware Project      

        You will want to have a config files for each of your differnt sensors or pi's that you will deploy. In the end you will do most of the work withing an aplication.ex. Other than that you will want to figure the config.ex and then the mix.ex to ensure that you have the right dependencies.

        sensor_hub will handle dependencies, manage configuration, provide the glue code, and implement the life cycle of the project you will need to:
            Add the path and hex dependencies
            Provide the configuration for the project
            Create a sensor wrapper so each sensor have a uniform interface in lib/sensor_hub/sensor.ex
            Start each of the sensor dependencies and the HTTP data publisher

        Configure the Name
            Lets name the of the project:
                sensor_hub/config/targets.exs
                config :mdns_lite,
                ...comments...
            host: [:hostname, "hub"]

            Before when we would nerves.local it was because of this line here not we can hub.local

        Include Dependencies for Sensors
            Okay so we are not starting to normalize the data from the sensors. We will do this with the file /sensor_hub/sensor.ex.

            sensor.ex
                defstruct [:name, :fields, :read, :convert]

                def new(name) do
                    %__MODULE__{
                    read: read_fn(name),
                    convert: convert_fn(name),
                    fields: fields(name),
                    name: name
                    }
                end

                #then we need fields(), read(), convert()
                def fields(SPG40), do: [:voc_index]
                def read(SPG40), do: fn -> Sgp40.get_measurement() end
                def convert_fn(SGP40) do
                    fn reading ->
                    Map.take(reading, [:voc_index])
                    end
                end

            With these for each sensor we are now passing the GenServer by name to the new that will start to take measurements from each sensor and turn the general values into something that we can use for each sensor.

            Here are some lines to put into iex so you can test everything:
                alias SensorHub.Sensor

                Bme280.start_link()
                Sgp40.start_link()
                TSL25911FN.start_link()
                LTR390_UV.start_link()

                bme = Sensor.new(Bme280)
                sgp = Sensor.new(Sgp40)
                tsl = Sensor.new(TSL25911FN)
                ltr = Sensor.new(LTR390_UV)

                Sensor.measure(bme)
                Sensor.measure(sgp)
                Sensor.measure(tsl)
                Sensor.measure(ltr)

            To go over a few things the code sinpets above are set to work when the readings give you the exact keys in the map as the fields. I had to do some work to make what I have work as most all the readings will return something like %{last_reading: last_reading} with last_reading having some reference to the values that it will have in it.