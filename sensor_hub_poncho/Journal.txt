Chapter 1: Elixir and Nerves for IoT
    You will understand the way in which Nerves can help with IoT (Internet of Things). You will build your Pi and then flash the Nerves bare-bones and then make sure it can connect wirelessly to the main computer without any direct connections.

    Why Nerves for IoT?
        IoT is all about interconnected computational Devices geographically distributed. It is a way to keep track of the cars or devices on your network so you can keep live up to date data about any node on the network. Nerves comes in as it will allow you to use consumer-available hardware to build everything from scratch.

    Time-Series Sensor Hub
        You will use Nerves to framework to build the sensor hub and then use Phoenix to build a RESTful API.

        Although you could use PostgreSQL for this the nature of the data will be time-series. Thus we want to use a data-base that is built around that, so TimescaleDB will work well here. This will automatically parse your data into describe chunks that will be more able to be used for our project. 

        To Note: There is even a space partition for the data that can be helpful for making sure that you are noting where the data is coming from this would work well for any true weather app as where the data comes from can be crucial.

    Laying Our the Architecture
        We will have: 
            Data Stations
            {
                Nerves Weather Stations
            }
            Data Transfer
            {
                Public Internet
            }
            Public Interface
            {
                Phoenix REST API
                Time-series Database
                Grafana
                Users
            }
        
        Definition: Cardinality
            This is the amount of Data that a column should have. A UserID should have high cardinality as each user will have their own unique ID, but something like User_Type will have low cardinality as each user will only have 3 or more values: Admin, Basic, Paid, etc.

        Once we have the node up we will use Phoenix to push the data onto the DB and once that is done the Phoenix part will be over (unless you want to post the data). But for the simple case you can use Grafana to visualize the data.

        New Tech: Grafana is used to connect to different databases, it will be hosted via Docker and will help us interact and visualize the data we are receiving. 

    Organizing Your Nerves Project
        Nerves Projects have their own structure that make embedding an Elixir project really convenient. 

        Planning Features
            Here are the individual features we need to build:
                Each Sensor will need to have its own GenServer and will be responsible for collecting it's sensor's measurements
                Our Raspberry Pit will have a GenServer that will capture measurements from the connected sensors and publish them to Phoenix API
                Nerves Firmware will start all the GenServers and the HTTP Publisher GenServer. This is the glue that will hold everything together.
        
        Organizing the Project
            We will use what is called a Poncho Project for Nerves as it will help us keep the Elixir project structured as well as all the Firmware of the project. Thus allowing us to have decencies separate and still allowing us to share it we need. 
            
            Definition: Poncho Project
                Alternative to umbrella projects: Poncho projects are a way to organize Elixir applications that are related but don't require the strict structure and interdependencies of an umbrella project.
            
            Here is the poncho project structure:
                |-- Sensor_hub_poncho
                    |-- publisher
                    |-- sensor_hub
                    |-- veml6030

                    This the top level will be created with a simple mkdir and then the subdirectories can be made with mix new and should have their own config. 

                sensor_hub is your firmware project this should deal with:
                    configuration, life-cycle concerns, dependencies, and glue code
                    So you will need to add other projects into the dependencies of the sensor_hub
                
            Poncho Projects will also have 2 types of dependency projects:
                Hardware dependency projects; these don't need firmware as you will write to the hardware interfaces. veml6030 is like this as you will only wrap the light sensor.

                Hardware-independent dependency; this implies that you will have code that will go to many types of hardware and will need to run on all of them. *publisher* is an example of this, it provides our HTTP API client. 

            Firmware projects will connect to dependency projects using path dependencies.

    Assembling the Weather Station
        We will need an sensor array for this project as many times it will need to be build with solder and a breakout board, but we will use a solderless board called Qwiic Connect System.

        Definition: I2C
            Inter-Integrated Circuit is a communication protocol that allows us to connect multiple external devices to one or more hosts. 

        Gathering Hardware
            Check out all the bookmarks but I think I have everything I need with the links that Cut sent.

        Assembling the Sensor Hub
            
Chapter 2 Wirelessly Reading Sensor Data (15)
    Creating a Network-Enabled Sensor Hub Project
        We want to generate a new Nerves Project (I made sure that I have all the needed libs for Nerves with the site https://hexdocs.pm/nerves/installation.html)
        Burning the Firmware
        Connecting the device via SSH
        Setting the network settings.

        First we will start by creating the top level directory.
            $ mkdir sensor_hub_poncho
            $ cd sensor_hub_poncho
            $ mix nerves.new sensor_hub
        
        For the next parts we need to tell Nerves what "target" you're acting upon. Also be ready to burn the firmware to the SD card and be sure that it is the only card installed. 
            $ cd sensor_hub
            $ export MIX_TARGET=rpi0
            $ mix deps.get
            ...
            $ mix firmware

            # I got an error here that said that I have a version mismatch for Erlang so I went ahead and installed Erlang version 27
                # Step 1: Install Erlang versions
                asdf install erlang 27.0
                asdf install erlang 28.0

                # Step 2: Install matching Elixir versions
                asdf install elixir 1.19.0-rc.0-otp-27
                asdf install elixir 1.19.0-rc.0-otp-28

                # Step 3: Set global Elixir version to OTP 28 (temporary or overwritten later)
                asdf global elixir 1.19.0-rc.0-otp-28

                # Step 4: Set global Elixir version to OTP 27 (final)
                asdf global elixir 1.19.0-rc.0-otp-27

                # Step 5: Set global Erlang version to match Elixir OTP 27
                asdf global erlang 27.0

                # Step 6: Clean and rebuild your Nerves project (run inside project folder)
                rm -rf _build deps
                mix deps.get
                mix compile

                # Step 7: Verify installed versions
                erl -version
                elixir --version

                # Step 8: To switch to Erlang 28 + Elixir OTP 28 when needed (per shell session)
                asdf shell erlang 28.0
                asdf shell elixir 1.19.0-rc.0-otp-28

                # Alternatively, create a `.tool-versions` file in the project directory:
                # erlang 28.0
                # elixir 1.19.0-rc.0-otp-28

                # Optional:
                # - Create `.tool-versions` files per project for automatic version switching.
                # - Remove any system-wide Erlang/Elixir versions outside `asdf` to avoid conflicts.
                # - Ensure your shell config loads `asdf` properly.

                # This then gave me an error about needing an other version of elixir so again we change the version
                asdf install elixir 1.18.3-otp-27
                asdf global elixir 1.18.3-otp-27

                # Then rebuild
                mix deps.clean --all
                mix deps.get
                mix deps.compile
                mix firmware

                ...
                $ mix burn
            ==> nerves
            ==> sensor_hub
            Nerves environment
            MIX_TARGET: rpi0
            MIX_ENV: dev
            Use 14.84 GiB memory card found at /dev/rdisk2? [Yn] y
            100% [====================================] 33.32 MB in / 35.76 MB out
            Success!
            Elapsed time: 4.765 s

        We now have a firmware burned into the Raspberry Pi and you can now insert the card into the Pi. Let's turn it on and SSH into it

            ssh nerves.local
            ...
            iex(1)> hostname()
            "nerves-dc74"
            iex(2)> exit()
            Connection to nerves.local closed

                    # 
                        At the moment the ssh isn't working so I'm going to try to go right to WIFI.
                            You need to add :inets to the extra_applications.

                            Then you can set the wifi network with Vintage.Net.configure()
                                iex(1)> VintageNet.configure("wlan0", %{
                                ...(1)> type: VintageNetWiFi,
                                ...(1)> vintage_net_wifi: %{
                                ...(1)> networks: [%{
                                ...(1)> key_mgmt: :wpa_psk,
                                ...(1)> ssid: "<YOUR NETWORK NAME>",
                                ...(1)> psk: "<YOUR WIRELESS PASSWORD>"
                                ...(1)> }]
                                ...(1)> },
                                ...(1)> ipv4: %{method: :dhcp}
                                ...(1)> })

                        This won't work for me as I can't SSH atm so I will create a hardcoded version of the setting. To do so I need to create a file under:
                            rootfs_overlay/etc/vintage_net/config/network.config

                        Once that was done you need to add this line to the release within the mix.exs:
                            rootfs_overlay: "rootfs_overlay",

                        With these settings:
                            [
                                {
                                    "wlan0",
                                    %{
                                    type: VintageNetWiFi,
                                    vintage_net_wifi: %{
                                        networks: [
                                        %{
                                            key_mgmt: :wpa_psk,
                                            ssid: "YourWiFiSSID",
                                            psk: "YourWiFiPassword"
                                        }
                                        ]
                                    },
                                    ipv4: %{method: :dhcp}
                                    }
                                }
                            ]

                        Then I need to get the new deps and create the new firmware then burn it to the SD card.
                            MIX_TARGET=rpi0
                            mix firmware
                            mix burn

                        That didn't work so now I'm trying to be sure that I have everything installed. Check out this page to help you get everything installed.
                        https://hexdocs.pm/nerves/installation.html
                        It seems that the wx install isn't working for that page and I found that wx is not autoinstalled with the latest version of Unbuntu so I found this page:
                        https://askubuntu.com/questions/1522789/e-unable-to-locate-package-libwxgtk3-0-gtk3-dev

                        I have everything I think I need installed atm I will try to redo the firmware and burn.

        Okay so check out this site in-order to get the auto connect for the wifi (https://github.com/nerves-networking/vintage_net). With making sure that the right firmware (rpi3a) and setting the right version of the wifi setup.
            config :vintage_net,
            regulatory_domain: "US", # Change to match your area
            config: [
                {"eth0", %{
                type: VintageNetEthernet,
                ipv4: %{
                    method: :dhcp
                }
                }},
                {"wlan0",
                %{
                    type: VintageNetWiFi,
                    vintage_net_wifi: %{
                    networks: [
                        %{
                        key_mgmt: :wpa_psk,
                        ssid: "Your WiFi SSID",
                        psk: "passphrase or psk",
                        }
                    ]
                    },
                    ipv4: %{method: :dhcp},
                }
                }
            ]

    Capturing Sensor Data
        Okay so now that we are ready to move onto the capture part of the process we need to download the spec sheet for the environmental hat (https://www.waveshare.com/environment-sensor-hat.htm). Here are some of the information that we will need:
            Light Sensor
                I2C address: 0x29
            Temp/Humidity/Air Pressure
                I2c address: 0x76
            Motion Sensor: 
                I2C adress: 0x68
            UV Sensor:
                I2C address: 0x53
            VOC Sensor:
                I2C address: 0x59

        These might be different for your device I was able to look up the sensor data on line and it even has them on the board itself. Some of the sensors will have different sensitivities so be sure to check those out too.

        Now let's change a few deps and then upload the new firmware. 
            $ mix deps.get
            ...
            $ mix firmware
            ...
            $ mix upload
            ...
            $ ssh nerves.local
            ...

        So again my current settings I was unable to use the nerves.local so I had to create an firmware update script and then use that to upload it to the pi.
            mix firmware.gen.script # This is instead of the mix upload
            ./upload.sh 192.168.x.x $ Your IP address of the pi

        Now you can ssh into the device.
            ssh 192.168.x.x
                    This is the way to do it with the basic sensor that the book is using.
                    Here is where we will start to take some the sensor data.
                        ex(1)> alias Circuits.I2C
                        Circuits.I2C
                        iex(2)> sensor = 0x29 # This is the address of the light sensor
                        72
                        iex(3)> command = <<0>>
                        <<0>>
                        iex(4)> byte_size = 2
                        2
                        iex(5)> {:ok, i2c_ref} = I2C.open("i2c-1")
                        {:ok, #Reference<0.1635386997.268828675.62058>}
                        iex(6)> <<value::little-16>> = I2C.write_read!(i2c_ref, sensor, command, 2)
                        <<1, 0>>
                        iex(7)> value |> inspect(base: :binary)
                        "0b0"

                    With the value of 0b0 being returned we know that the sensor is turned off. Let's turn it on.
                        iex(8)> config = 0b0001100000000000
                        6144
                        iex(9)> Circuits.I2C.write(i2c_ref, sensor, <<0, config::little-16>>)
                        :ok
                        iex(10)> <<value::little-16>> = I2C.write_read!(i2c_ref, sensor, command, 2)
                        <<0, 24>>
                        iex(11)> value |> inspect(base: :binary)
                        "0b1100000000000"

        This didn't work for me so Ill try an other way
            alias Circuits.I2C
            import Bitwise

            sensor = 0x29               # Sensor I2C address
            command_bit = 0x80          # Command bit to indicate command register (depends on sensor)
            enable_register = 0x00      # Register address to enable power and ALS
            config_register = 0x01      # Configuration register
            data_register = 0x14        # Data register address (where readings start)

            # Bit flags to enable power and ALS (ambient light sensing)
            enable_power_on = 0x01
            enable_als_enable = 0x02

            # Combine flags with bitwise OR
            enable_value = enable_power_on ||| enable_als_enable

            # Open I2C bus
            {:ok, i2c_ref} = I2C.open("i2c-1")

            # Write to enable register with command bit set
            I2C.write(i2c_ref, sensor, <<command_bit ||| enable_register, enable_value>>)

            # Optionally configure other registers here...

            # Read 2 bytes from the data register
            <<raw_value::little-16>> = I2C.write_read!(i2c_ref, sensor, <<command_bit ||| data_register>>, 2)

            IO.inspect(raw_value, base: :binary)

        Now we can start to do something with the sensor.
            iex(12)> light_reading = 4
            4
            iex(13)> <<value::little-16>> =
            ...(13)> Circuits.I2C.write_read!(i2c_ref, sensor, <<light_reading>>, 2)
            iex(14)> value
            440

        We get a value back. Now, put your hand over the sensor so that thereâ€™s less light and see if the value is lower:
            iex(15)> <<value::little-16>> =
            ...(15)> Circuits.I2C.write_read!(i2c_ref, sensor, <<light_reading>>, 2)
            iex(16)> value
            40

        Now we can try and transfor the data into something useful.
            iex(17)> measure_light = fn i2c, address ->
            ...(17)> <<value::little-16>> = I2C.write_read!(i2c, address, <<4>>, 2)
            ...(17)> value * 0.2304
            ...(17)> end
            #Function<43.97283095/2 in :erl_eval.expr/5>

            iex(16)> measure_light.(i2c_ref, sensor)
            57.6
        
    What you have done...
        Great job so far. You have created your first poncho project, you update the firmware and flashed it to an SD card, you then updated the config file so that your pi will automatically connect to the wifi network, you then started the sensor and got some raw values back, lastly you created a function that will turn the raw data into something that is more managable. 